extends live_coding

global !p

def cycle_index():
	i = vim.current.window.cursor[0] - 1
	regex = f'^\s*d([0-9]+)'
	while i >= 0:
		m = re.match(regex, snip.buffer[i])
		if m:
			return int(m.group(1))
		i -= 1
	return 0

endglobal

# JIT like

snippet j "Sound pattern" b
d${1:`!p if not snip.c: snip.rv = cycle_index() + 1`} $ $0
endsnippet

snippet jj "Sound pattern on new line" b
d${1:`!p if not snip.c: snip.rv = cycle_index() + 1`}
$ $0
endsnippet

snippet jo "Play once independant of cycles. Slow ruins it." b
once $$1 s "${VISUAL}$2"
endsnippet

snippet js "Silence a pattern" b
d${1:`!p if not snip.c: snip.rv = cycle_index()`} silence
endsnippet

snippet j1 "Silence all except this" b
solo ${1:`!p if not snip.c: snip.rv = cycle_index()`}
endsnippet

snippet ju "Undo solo action" b
unsolo ${1:`!p if not snip.c: snip.rv = cycle_index()`}
endsnippet

snippet D "Deconstruct" b
deconstruct ${1:n} ${2:str}
endsnippet

# https://github.com/tidalcycles/Tidal/issues/530
snippet set "Interpolation. Only works for sound" w
setS "foo" (iter 4 "bd sn [cp cp:4] bd*8")
d1 $ s "bd*2 cp:3 bd ^foo"
endsnippet

snippet mm "Mappings to trigger short sounds" w
nmap <M-z> :TidalSend1 asap $ s "glitch:3" <cr>
nmap <M-x> :TidalSend1 asap $ s "glitch:6" <cr>
endsnippet

# Envelopes
snippet et "triange" w
smooth "$1"
endsnippet

snippet el "Linear envelope. Use for gain with trigger, etc. We can range it" w
envL
endsnippet

# Functions

snippet .. "" w
${1:0} .. $2
endsnippet

snippet <~ "Unpredictable when values change during cycle" w
($1 <~)
endsnippet

snippet ~> "" w
($1 ~>)
endsnippet

snippet rr "Use to change randomness" w
(0.000000${1:1} <~)
endsnippet

snippet fap "Spread chords of note numbers over time" w
arpg "$1"
endsnippet

snippet fa "With arpeggiate modes" w
arp "$1"
endsnippet

snippet fd "Degrade by 50%. Similar to ?" w
degrade
endsnippet

snippet fdb "Degrade by x amount" w
degradeBy $0
endsnippet

snippet rot "Rotate to the left. Preserves the structure (~). _ and @n are attached to element" w
rot "$1"
endsnippet

snippet fc "Concat for different cycles. Pattern maintains it's original duration." w
cat [$1]
endsnippet

snippet frc "Pick random every cycle" w
randcat [$1]
endsnippet

snippet ffc "concat for same cycle" w
fastcat [${VISUAL}$1]
endsnippet

snippet fA "same as cat family, but applies to diff cycles simlar to <> " w
append (${VISUAL}$1) ($2)
endsnippet

snippet ffA "same as cat family, but applies to diff cycles simlar to <> " w
fastAppend (${VISUAL}$1) ($2)
endsnippet

snippet fwi "" w
within (0.${1:0}, ${2:1}) ($3)
endsnippet

snippet fZ "" w
zoom (0.${1:0}, ${2:1})
endsnippet

snippet fz "" w
compress (0.${1:0}, ${2:1})
endsnippet

snippet fpl "" w
palindrome
endsnippet

snippet fin "" w
inside "$1" ($2)
endsnippet

snippet fbr "Breakbeat feel. every 2 squash the pattern to fit half of cycle and offset by quarter" w
brak
endsnippet

snippet fbi "" w
bite ${1:n} "$2"
endsnippet

snippet fch "Same as bite but also speeds. Similar to hurry vs speed" w
chew ${1:n} "$2"
endsnippet

snippet fsl "Same as bite but for samples" w
slice ${1:8} "$2"
endsnippet

snippet fspl "Same as chew but for samples" w
splice ${1:8} "$2"
endsnippet

snippet fcho "Cuts each sample into n parts. Granula synthesis effect" w
chop ${1:8}
endsnippet

snippet flo "Squash sample rate into n cycles. Only works for samples." w
loopAt ${1:8}
endsnippet

snippet fp "Repeats each event the given number of times. Excluding rests (~)" w
ply "$1"
endsnippet

snippet pif "" w
fix ($1) (${2:s} "$3")
endsnippet

snippet fj "" w
jux ($1)
endsnippet

snippet re "" w
rev
endsnippet

snippet ss "" w
slow $0
endsnippet

snippet ff "" w
fast $0
endsnippet

snippet fra "" w
range ${1:lo} ${2:hi} ${3:sine}
endsnippet

snippet fseg "Useful for turning a continuous pattern into a discrete one." w
(segment ${1:16} $ range $2 $3 $ $4)
endsnippet

snippet fsn "iter, operator, fun. Usually embedded in other function (e.g. n or up). Does not work with control patterns?" w
snowball ${1:4} (${2:+}) (${3:slow 1})
endsnippet

snippet fso "less general snowball. Applies new pattern by multiplying previous. Works with control patterns" w
soak ${1:4} ($2)
endsnippet

snippet fw "" w
whenmod ${1:9} ${2:7} ($3)
endsnippet

snippet fs "" w
struct ($1)
endsnippet

snippet fm "Binary gain of 1s and 0s. It's like gain but with binary functions like inv" w
mask ($1)
endsnippet

snippet fse "1(t) for the first pattern. 0(f) for the second one. Structure comes from source patterns." w
sew "$1" ($2) ($3)
endsnippet

snippet fst "1(t) for the first pattern. 0(f) for the second one. Structure comes from binary pattern." w
stitch "$1" ($2) ($3)
endsnippet

snippet fint "16 cycles. Sine waves. Changes shape control." w
interlace ($1) ($2)
endsnippet

snippet fint1 "Interlace manually" w
d1 $ n $1 # s "$2" # ${3:legato} (slow ${4:16} $ ${5:sine} * ${6:1.2})
d2 $ n $1 # s "$2" # $3 (${7:8} <~ (slow $4 $ $5 * $6))
endsnippet

snippet fwe "Similar to interlace. But can me customized more easily" w
weave ${1:16} (${2:gain} ${3:sine}) [${4:pat1}, ${5:patn}]
endsnippet

snippet fe "" w
every $1 ($2)
endsnippet

snippet ffe "Applying every multiple times" w
foldEvery [${1:3}, ${2:4}] ($5)
endsnippet

snippet frx "" w
rangex ${1:lo} ${2:hi} ${3:sine}
endsnippet

snippet fr "Generates numbers from 0 to n-1 inclusive" w
run $1
endsnippet

snippet sc "" w
scale "${1:indian}" "$2"
endsnippet

snippet gs "Build and name new scale" w
let scale = getScale (scaleTable ++ [("$1", [$2])])
endsnippet

snippet ts "Apply scale without naming it" w
toScale [$1] "$2"
endsnippet

snippet fo "Superimpose and shift in time" w
off $1 ($2)
endsnippet

snippet fsu "Superimpose" w
superimpose ($1)
endsnippet

snippet fl "" w
layer [${1:id},  $2]
endsnippet

snippet <> "Use inside function like (n etc...)" w
overlay ("$1" "$2")
endsnippet

snippet fnu "nudge" w
nudge "$1"
endsnippet

snippet fi "Pushes divisions to left" w
iter "$1"
endsnippet

snippet fC "Applies functions to divisions (similar to iter, but moves to right)" w
chunk ${1:4} ($2)
endsnippet

snippet fh "" w
hurry "$1"
endsnippet

snippet fsw "1/3. Swing can push elements out of existence if it is split between arcs" w
swing $1
endsnippet

snippet fswb "1/2 for some reason just pushes element normally. If we use div by 2 sequences" w
swingBy (${1:1/3}) ${2:4}
endsnippet

snippet in "" w
inv $1
endsnippet

snippet fg "" w
ghost
endsnippet

snippet ffsp "" w
fastspread ($) [$1]
endsnippet

snippet fsp "" w
spread ($) [$1]
endsnippet

# Random functions

snippet rs "" w
sometimes ($1)
endsnippet

snippet rsb "" w
sometimesBy "$1" ($2)
endsnippet

snippet rsc "" w
someCycles ($1)
endsnippet

snippet rscb "" w
someCyclesBy $1 ($2)
endsnippet

snippet rC "Repeat each random cycle" w
repeatCycles ${1:3}
endsnippet

snippet rsp "" w
spreadChoose ($) [$1]
endsnippet

snippet rc "Continous! So it cannot be used as structure pattern" w
choose [$1]
endsnippet

snippet rwc "Continous! Always use numbers (more safe)" w
wchoose [($1,$2),($3,$4)]
endsnippet

snippet rscr "Divides the pattern and returns a new pattern by randomly selecting. Can repeat." w
scramble ${1:3} ""
endsnippet

# Controls

snippet fco "Replace pattern (including its stucture)" w
const ($1)
endsnippet

snippet cw "" w
vowel $0
endsnippet

snippet cr "1 - 16. 1 results in a drastic bit of reduction" w
crush $0
endsnippet

snippet cs "simple distortion. 0 to 1. 1 max distortion" w
shape $0
endsnippet

snippet ct "Triode tanh distortion 0 to n" w
triode $0
endsnippet

snippet cf "Absolute frequency shift" w
fshift $0
endsnippet

snippet co "" w
octave $0
endsnippet

snippet le "" w
legato $0
endsnippet

snippet csq "simplistic pitch raising. 1 .. n" w
squiz $0
endsnippet

snippet cl "low pass filter" w
lpf $1
endsnippet

snippet clq "low pass filter" w
lpf $1 # lpq $0
endsnippet

snippet ch "high pass filter" w
hpf $1
endsnippet

snippet chq "high pass filter" w
hpf $1 # hpq $0
endsnippet

snippet dj "0-0.49 lpf, 0.51-1 hpf" w
djf $0
endsnippet

snippet csp "" w
speed $0
endsnippet

snippet cc "1..n - group, -1 only cut same samples, 0 no cutting. [1 2 n] cut pattern" w
cut $0
endsnippet

snippet coa "lowers the sample rate of a sample. i.e. 1 for original 2 for half, 3 for a third and so on." w
coarse $0
endsnippet

snippet cat "changes the fade in time of a sample" w
attack $0
endsnippet

snippet ca "" w
accelerate $0
endsnippet

snippet cg "" w
gain $1
endsnippet

snippet ro "" w
room $1
endsnippet

snippet cn "based on 60 beat temopo no matter cps" w
nudge "$1"
endsnippet

snippet cb "changes the start position of a sample" w
begin "$1"
endsnippet

snippet cwa "0-100(max)" w
waveloss "$1"
endsnippet

snippet ctd "tremolo depth. 0 - 1" w
tremdp "$1"
endsnippet

snippet ctr "tremolo rate" w
tremr "$1"
endsnippet

snippet cd "" w
delay "$1" # delayfb "$2" # delayt "$3"
endsnippet

snippet lo "Lock delay to cps" w
lock 1
endsnippet

# Oscillators

snippet os "" w
sine
endsnippet

snippet ot "A triangle wave, starting at 0, then linearly rising to 1 halfway through a cycle, then down again." w
tri
endsnippet

snippet osa "" w
saw
endsnippet

snippet oc "sine shifted in time by a quarter of a cycle" w
cosine
endsnippet

snippet osq "A squarewave, starting at 0, then going up to 1 halfway through a cycle" w
square
endsnippet

snippet ori "" w
irand $1 + 1
endsnippet

snippet op "random walk random" w
perlin
endsnippet

# Patterns

snippet pst "stut :: Pattern Integer -> Pattern Double -> Pattern Rational -> ControlPattern -> ControlPattern" w
stut ${1:depth} ${2:fb} ${3:delay}${VISUAL}
endsnippet

snippet psw "stut :: Pattern Integer -> Pattern Double -> Pattern Rational -> ControlPattern -> ControlPattern" w
stutWith ${1:2} ${2:0.5} (${3:fn})${VISUAL}
endsnippet

snippet pb "max 255 values" w
binary $1
endsnippet

snippet pbn "inf values. It needs to be 2**n + 1 (like 251)" w
binaryN $1 ${2:512}
endsnippet

snippet pa "8 bit like binary" w
ascii $1
endsnippet

snippet prw "L-system. No spaces after commas allowed. Wraps if taken more elements than exists" w
(step' ["$1", "$2"] (take ${3:24} $ lindenmayer ${4:5} "0:$5,1:$6,~:$7" "0"))
endsnippet

snippet ppar "" w
stack [
  ${VISUAL}$1,
  $2
]
endsnippet

snippet p "$6 means how many repetitions for event divided by elements in cycle" w
let ${1:pats} =
      [
        ("${2:a}", stack [$3
                    ]
        ),
        ("${4:b}", stack [$5
                    ]
        )
      ]
in
d1 $ ur $6 "$7" $1 []
endsnippet

snippet pfx "ur with effects" w
let ${1:pats} =
      [
        ("${2:a}", stack [$3
                    ]
        ),
        ("${4:b}", stack [$5
                    ]
        )
      ]
      fx = [("${6:a}", ($7))]
in
d1 $ ur $8 "$9" $1 fx
endsnippet

snippet psp "Similar to SC Pspawner. Stack by default" b
do
{
  resetCycles;
  d${1:1} $ seqP [
    (${2:0}, ${3:12}, ${VISUAL}$4)$5
  ]
}
endsnippet

snippet ps "Similar to SC Pspawner. Stack by default" w
seqP [(0, ${1:24},
  ${VISUAL}$2)]
endsnippet

snippet psl "To loop specific amount wrap inside seqP. Similar as wrapping in Pn in SC" b
do
{
  resetCycles;
  d${1:1} $ seqPLoop [
    (${2:0}, ${3:12}, ${VISUAL}$4)$5
  ]
}
endsnippet

snippet pl "Only offsets seqPLoop first cycle " b
rotL ${1:3}
endsnippet

snippet pls "Start at specific cycle" b
do
{
  resetCycles;
  d${1:1} $ rotL ${2:4} $ seqP [
    (${3:0}, ${4:12}, ${VISUAL}$5)$6
  ]
}
endsnippet

# Transistions

snippet tc "transistion by replacaing events" w
clutch ${1:`!p if not snip.c: snip.rv = cycle_index()`} $ $0
endsnippet

snippet tci "transistion by replacaing events in n of cycles" w
clutchIn ${1:`!p if not snip.c: snip.rv = cycle_index()`} ${2:10} $ $0
endsnippet

snippet tf "transistion by fading gain" w
xfade ${1:`!p if not snip.c: snip.rv = cycle_index()`} $ $0
endsnippet

snippet tfi "transistion by fading gain in n of cycles" w
xfadeIn ${1:`!p if not snip.c: snip.rv = cycle_index()`} ${2:10} $ $0
endsnippet

snippet ti "morph control values between patterns in four cycles" w
interpolate ${1:`!p if not snip.c: snip.rv = cycle_index()`} $ $0
endsnippet

snippet tii "morph control values between patterns in n cycles" w
interpolateIn ${1:`!p if not snip.c: snip.rv = cycle_index()`} ${2:10} $ $0
endsnippet

snippet tt "Trigger on specified channel revaluation (can be itself)" w
trigger ${1:`!p if not snip.c: snip.rv = cycle_index()`} $ $0
endsnippet

# Language

snippet do "Block" b
do
	${VISUAL}$0
endsnippet

snippet fn "Function" b
$1 = ${VISUAL}$0
endsnippet

snippet v "Assign variable in scoped environment" b
let $1 = ${VISUAL}$0
endsnippet

# Samples/buffers

snippet dck "" w
clubkick:${1:0}
endsnippet

snippet ddk "" w
drumtraks:${1:6}
endsnippet

snippet dkl "" w
kicklinn:${1:3}
endsnippet

snippet dho "open hat" w
ho:${1:0}
endsnippet

snippet dhc "closed hat" w
hc:${1:0}
endsnippet

# Chords and scales

# https://en.wikipedia.org/wiki/List_of_chords

# etc
snippet five "Perfect fifth " w
[0, 7]
endsnippet

snippet min6th "Emotion anguish. But its subjective. Maybe its pulling etc." w
[0, 8]
endsnippet

snippet maj6th "" w
[0, 8]
endsnippet

snippet 9s5 "Octave chord" w
[0, 1, 13]
endsnippet

snippet m9s5 "Octave chord but dramatic" w
[0, 1, 14]
endsnippet

snippet 7s5f9 "Serious" w
[0, 4, 8, 10, 13]
endsnippet

# major
snippet maj "" w
[0, 4, 7]
endsnippet

snippet maj7 "" w
[0, 4, 7, 11]
endsnippet

snippet maj9 "Almost double major tom" w
[0, 4, 7, 11, 14]
endsnippet

snippet dom7 "More dissonant long major" w
[0, 4, 7, 10]
endsnippet

snippet dom7a "More dissonant long major" w
0 4 7 10
endsnippet

snippet indian "Last note is amazing" w
0 4 5 7 10
endsnippet

snippet six "" w
[0, 4, 7, 9]
endsnippet

snippet 6by9 "Super happy long" w
[0, 4, 7, 9, 14]
endsnippet

snippet 7f9 "Dramatic and shocking" w
[0, 4, 7, 10, 13]
endsnippet

snippet 7f10 "" w
[0, 4, 7, 10, 15]
endsnippet

snippet eleven "Expansive" w
[0, 4, 7, 10, 14, 17]
endsnippet

snippet 11s "Wonky expansive" w
[0, 4, 7, 10, 14, 18]
endsnippet

snippet maj11 "Expansive, but happier?" w
[0, 4, 7, 11, 14, 17]
endsnippet

# minor
snippet min "" w
[0, 3, 7]
endsnippet

snippet m6 "" w
[0, 3, 7, 9]
endsnippet

snippet min7 "" w
[0, 3, 7, 10]
endsnippet

snippet min9 "" w
[0, 3, 7, 10, 14]
endsnippet

snippet m11 "" w
[0, 3, 7, 10, 14, 17]
endsnippet

snippet m6by9 "" w
[0, 3, 7, 9, 14]
endsnippet

snippet m7f9 "Dramatic" w
[0, 3, 7, 10, 13]
endsnippet

# diminished
snippet dim "Very serious, like asking a question" w
[0, 4, 6]
endsnippet

snippet dim7 "More expansive than dim" w
[0, 4, 6, 9]
endsnippet

snippet 7f5 "Ugly" w
[0, 4, 6, 10]
endsnippet

snippet 7s5 "Ugly and bright" w
[0, 4, 8, 10]
endsnippet

snippet m7f5 "Pathetic" w
[0, 3, 6, 10]
endsnippet

# augmented
snippet aug "Sadder major" w
[0, 4, 8]
endsnippet

snippet msharp5 "More expansive sad minor" w
[0, 3, 8]
endsnippet

# suspended
snippet sus2 "Bright clean, beutiful. Sounds lower than major" w
[0, 2, 7]
endsnippet

snippet sus4 "More bright than sus2." w
[0, 5, 7]
endsnippet

snippet 7sus2 "" w
[0, 2, 7, 10]
endsnippet

snippet 7sus4 "" w
[0, 5, 7, 10]
endsnippet

snippet 7sus4a "" w
0 5 7 10
endsnippet

snippet 9sus4 "" w
[0, 5, 7, 10, 14]
endsnippet

# Chords

# https://www.ableton.com/en/manual/live-midi-effect-reference/

# [0,1,2,3]
# using without chords is unpredictable

snippet up "0 1 2 3" w
up
endsnippet

snippet down "3 2 1 0" w
down
endsnippet

snippet updown "0 1 2 3 2 1" w
updown
endsnippet

snippet downup "3 2 1 0 1 2" w
downup
endsnippet

snippet converge "0 3 1 2" w
converge
endsnippet

snippet diverge "2 1 3 0" w
diverge
endsnippet

snippet disconverge "0 3 1 2 1 3 0" w
disconverge
endsnippet

snippet pinkyup "0 3 1 3 2 3" w
pinkyup
endsnippet

snippet pinkyupdown "0 3 1 3 2 3 2 3 1 3" w
pinkyupdown
endsnippet

snippet thumbup "0 1 0 2 0 3" w
thumbup
endsnippet

snippet thumbupdown "0 1 0 2 0 3 0 2 0 1" w
thumbupdown
endsnippet

# OSC Control
snippet cF "Float" w
cF 1 "$1"
endsnippet

snippet cI "Integer" w
cI 1 "$1"
endsnippet

snippet cS "String" w
cS 1 "$1"
endsnippet

snippet cB "Boolean" w
cB 1 "$1"
endsnippet

# Colors
# https://www.rapidtables.com/web/color
snippet "(c1|Blue)" "blue" r
-- Blue
endsnippet

snippet "(c2|Red)" "red" r
-- Red
endsnippet

snippet "(c3|Green)" "green" r
-- Green
endsnippet

snippet "(c4|Navy)" "blue" r
-- Navy
endsnippet

snippet "(c5|Aqua)" "cyan" r
-- Aqua
endsnippet

snippet "(c6|Olive)" "green" r
-- Olive
endsnippet

snippet "(c7|Maroon)" "red" r
-- Maroon
endsnippet

snippet "(c8|Teal)" "cyan" r
-- Teal
endsnippet

snippet "(c9|Plum)" "purple" r
-- Plum
endsnippet

snippet "(c10|Lime)" "green" r
-- Lime
endsnippet

snippet "(c11|Salmon)" "red" r
-- Salmon
endsnippet

snippet "(c12|Indigo)" "purple" r
-- Indigo
endsnippet

snippet "(c13|Grey)" "grey" r
-- Grey
endsnippet

snippet "(c14|Crimson)" "red" r
-- Crimson
endsnippet

snippet "(c15|Khaki)" "gold" r
-- Khaki
endsnippet

snippet "(c16|Brown)" "brown" r
-- Brown
endsnippet

snippet "(c17|Purple)" "purple" r
-- Purple
endsnippet

snippet "(c18|Tomato)" "orange" r
-- Tomato
endsnippet
